
REQUIREMENTS:
---------------------------------------------------------------------
Create a password strength widget that could be used in multiple forms. The widget should fulfill the following requirements:
(1) Follow best practices for determining password strength.
(2) Allow any number of strength ranges (ex. "weak", "good", "excellent", etc...) to be defined for each password field.
(3) Allow user to specify password rules that must be passed before a password's strength will be calculated.
(4) Be independent of page's HTML structure so the functionality can be used for any number of different login forms.

DISCUSSION:
---------------------------------------------------------------------
The definitive research on calculating password strength has been conducted by the National Institute of Standards and Technology (NIST) and documented in their "Electronic Authentication Guideline" (http://csrc.nist.gov/publications/nistpubs/800-63-1/SP-800-63-1.pdf). The NIST's recommendations for password strength calculations are located in Appendix A of the aforementioned document. The NIST defines a password's strength in terms of "entropy". Entropy is simply how random the characters in the password are. A password composed of more random characters will have a higher entropy value. For requirement #1 I used the entropy calculations defined in the Electronic Authentication Guideline for determining a password's entropy.

 The Electronic Authentication Guideline provides a detailed description of how to calculate entropy, but for the sake of brevity, here a simplified explanation on how it works:

    (1) Determine how many character sets the password is in. For example "test1234-=" contains three character sets: lowercase characters ("test"), numeric ("1234"), and special characters ("-=").
    (2) Calculate initial entropy value based on size of the character sets the password is in, the number of character sets the password is in, and the length of password.
    (3) Add bonus entropy for passwords that pass a dictionary test.

How much entropy does a "strong" or "weak" password have? That answer is subjective. For that reason, and to fulfill requirement #2, the password strength meter accepts an optional range of entropy values to define what constitutes weak or strong passwords. If no range is specified, a default is provided.

There are typically rules that must be passed before the password strength needs to be calculated. For example the user may be required to have a password that is 8 or more characters in length. To fulfill requirement #3 the password strength meter accepts a collection of regular expressions that will be tested against the current password before entropy is calculated.

Finally, it is important to make the password strength meter agnostic to the HTML structure of the form it will be used for. To accomplish this and to fulfill requirement #4 the password strength meter will need to be provided three pieces of information:
    (1) A reference to the <input> field used for the password.
    (2) A reference to the meter element (ex. a <div> that will expand and collapse as the password strength increases and decreases).
    (3) A CSS classname for each entropy range. The classname will be added to the meter element whenever the entropy of the password matches the given range.


PWSTRENGTHMETER API:
---------------------------------------------------------------------
PWStrengthMeter(fieldEl, meterEl, options)

Parameters:

* fieldEl {HTMLInput} The password field whose "onkeyup" event will be monitored.

* meterEl {HTMLElement} The password strength meter element whose className attribute will be updated
     based on the status ("valid" or "invalid") and range ("weak", "good", or "strong") of the password.

* options {Object} Optional configuration arguments that can be passed in to tailor the functionality of
     the class.

     - onChange {function} Listener to call whenever the password is changed. Returning false will
         cancel the setting of classNames on the meterEl. The function will be passed an object with the
         following attributes:
         {
             valid: < Boolean indicating whether the password passed all of the rules >,
             range:  < Object of range that the password matched >,
             invalidRules: < Array of the rules that failed to validate. Empty if valid is true >
         }

     - ranges {Object[]} An array of range objects that define a minimum and maximum number for a range that
         the password's calculated bits that will be compared against to determine if they fit in the given range.
         The "cls" attribute will be applied to the meterEl whenever the rule matches the calculated bitRange.
         The default ranges are:
         [
             { min: Number.NEGATIVE_INFINITY, max: 56, cls: "weak"},
             { min: 56, max: 80, cls: "good" },
             { min: 80, max: Number.POSITIVE_INFINITY, cls: "strong" }
         ]

     - rules {Object[]} An array of rule objects that will be tested agains the password.  Each rule object must
         have a "regex" attribute that will be tested via "regex.test(password)" and compared to the "result"
         boolean attribute to determine whether the rule has been successfully fulfilled. Default is no rules (ie []).
         Example of an array of rules:
         [
             {regex: /.{8,}/, result: true },   // length >= 8
             {regex: /[a-z]/i, result: true },  // Must contain at least one alpha character
             {regex: /[\W_]/, result: true },   // Must contain one symbol
             {regex: /^\d/, result: false }     // Cannot start with a number
         ]

     - clsValid {String} Optional class added to meterEl when the password is valid. Default is "valid".

     - clsInvalid {String} Optional class added to meterEl when the password is invalid. Default is "invalid".





